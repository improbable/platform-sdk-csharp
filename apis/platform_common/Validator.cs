// Generated by the protocol buffer compiler.  DO NOT EDIT!
// @TODO(OP-3783) Update Validator proto to proto 3 syntax to remove this genfile.
// source: validator.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Validator {

  /// <summary>Holder for reflection information generated from validator.proto</summary>
  public static partial class ValidatorReflection {

    #region Descriptor
    /// <summary>File descriptor for validator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ValidatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg92YWxpZGF0b3IucHJvdG8SCXZhbGlkYXRvchogZ29vZ2xlL3Byb3RvYnVm",
            "L2Rlc2NyaXB0b3IucHJvdG8i1AIKDkZpZWxkVmFsaWRhdG9yEg0KBXJlZ2V4",
            "GAEgASgJEg4KBmludF9ndBgCIAEoAxIOCgZpbnRfbHQYAyABKAMSEgoKbXNn",
            "X2V4aXN0cxgEIAEoCBITCgtodW1hbl9lcnJvchgFIAEoCRIQCghmbG9hdF9n",
            "dBgGIAEoARIQCghmbG9hdF9sdBgHIAEoARIVCg1mbG9hdF9lcHNpbG9uGAgg",
            "ASgBEhEKCWZsb2F0X2d0ZRgJIAEoARIRCglmbG9hdF9sdGUYCiABKAESGAoQ",
            "c3RyaW5nX25vdF9lbXB0eRgLIAEoCBIaChJyZXBlYXRlZF9jb3VudF9taW4Y",
            "DCABKAMSGgoScmVwZWF0ZWRfY291bnRfbWF4GA0gASgDEhEKCWxlbmd0aF9n",
            "dBgOIAEoAxIRCglsZW5ndGhfbHQYDyABKAMSEQoJbGVuZ3RoX2VxGBAgASgD",
            "OkkKBWZpZWxkEh0uZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucxj8+wMg",
            "ASgLMhkudmFsaWRhdG9yLkZpZWxkVmFsaWRhdG9yQgtaCXZhbGlkYXRvcmIG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { pbr::FileDescriptor.DescriptorProtoFileDescriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Validator.FieldValidator), global::Validator.FieldValidator.Parser, new[]{ "Regex", "IntGt", "IntLt", "MsgExists", "HumanError", "FloatGt", "FloatLt", "FloatEpsilon", "FloatGte", "FloatLte", "StringNotEmpty", "RepeatedCountMin", "RepeatedCountMax", "LengthGt", "LengthLt", "LengthEq" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class FieldValidator : pb::IMessage<FieldValidator> {
    private static readonly pb::MessageParser<FieldValidator> _parser = new pb::MessageParser<FieldValidator>(() => new FieldValidator());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FieldValidator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Validator.ValidatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldValidator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldValidator(FieldValidator other) : this() {
      regex_ = other.regex_;
      intGt_ = other.intGt_;
      intLt_ = other.intLt_;
      msgExists_ = other.msgExists_;
      humanError_ = other.humanError_;
      floatGt_ = other.floatGt_;
      floatLt_ = other.floatLt_;
      floatEpsilon_ = other.floatEpsilon_;
      floatGte_ = other.floatGte_;
      floatLte_ = other.floatLte_;
      stringNotEmpty_ = other.stringNotEmpty_;
      repeatedCountMin_ = other.repeatedCountMin_;
      repeatedCountMax_ = other.repeatedCountMax_;
      lengthGt_ = other.lengthGt_;
      lengthLt_ = other.lengthLt_;
      lengthEq_ = other.lengthEq_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldValidator Clone() {
      return new FieldValidator(this);
    }

    /// <summary>Field number for the "regex" field.</summary>
    public const int RegexFieldNumber = 1;
    private string regex_ = "";
    /// <summary>
    /// Uses a Golang RE2-syntax regex to match the field contents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Regex {
      get { return regex_; }
      set {
        regex_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "int_gt" field.</summary>
    public const int IntGtFieldNumber = 2;
    private long intGt_;
    /// <summary>
    /// Field value of integer strictly greater than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IntGt {
      get { return intGt_; }
      set {
        intGt_ = value;
      }
    }

    /// <summary>Field number for the "int_lt" field.</summary>
    public const int IntLtFieldNumber = 3;
    private long intLt_;
    /// <summary>
    /// Field value of integer strictly smaller than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IntLt {
      get { return intLt_; }
      set {
        intLt_ = value;
      }
    }

    /// <summary>Field number for the "msg_exists" field.</summary>
    public const int MsgExistsFieldNumber = 4;
    private bool msgExists_;
    /// <summary>
    /// Used for nested message types, requires that the message type exists.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MsgExists {
      get { return msgExists_; }
      set {
        msgExists_ = value;
      }
    }

    /// <summary>Field number for the "human_error" field.</summary>
    public const int HumanErrorFieldNumber = 5;
    private string humanError_ = "";
    /// <summary>
    /// Human error specifies a user-customizable error that is visible to the user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HumanError {
      get { return humanError_; }
      set {
        humanError_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "float_gt" field.</summary>
    public const int FloatGtFieldNumber = 6;
    private double floatGt_;
    /// <summary>
    /// Field value of double strictly greater than this value.
    /// Note that this value can only take on a valid floating point
    /// value. Use together with float_epsilon if you need something more specific.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatGt {
      get { return floatGt_; }
      set {
        floatGt_ = value;
      }
    }

    /// <summary>Field number for the "float_lt" field.</summary>
    public const int FloatLtFieldNumber = 7;
    private double floatLt_;
    /// <summary>
    /// Field value of double strictly smaller than this value.
    /// Note that this value can only take on a valid floating point
    /// value. Use together with float_epsilon if you need something more specific.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatLt {
      get { return floatLt_; }
      set {
        floatLt_ = value;
      }
    }

    /// <summary>Field number for the "float_epsilon" field.</summary>
    public const int FloatEpsilonFieldNumber = 8;
    private double floatEpsilon_;
    /// <summary>
    /// Field value of double describing the epsilon within which
    /// any comparison should be considered to be true. For example,
    /// when using float_gt = 0.35, using a float_epsilon of 0.05
    /// would mean that any value above 0.30 is acceptable. It can be
    /// thought of as a {float_value_condition} +- {float_epsilon}.
    /// If unset, no correction for floating point inaccuracies in
    /// comparisons will be attempted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatEpsilon {
      get { return floatEpsilon_; }
      set {
        floatEpsilon_ = value;
      }
    }

    /// <summary>Field number for the "float_gte" field.</summary>
    public const int FloatGteFieldNumber = 9;
    private double floatGte_;
    /// <summary>
    /// Floating-point value compared to which the field content should be greater or equal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatGte {
      get { return floatGte_; }
      set {
        floatGte_ = value;
      }
    }

    /// <summary>Field number for the "float_lte" field.</summary>
    public const int FloatLteFieldNumber = 10;
    private double floatLte_;
    /// <summary>
    /// Floating-point value compared to which the field content should be smaller or equal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatLte {
      get { return floatLte_; }
      set {
        floatLte_ = value;
      }
    }

    /// <summary>Field number for the "string_not_empty" field.</summary>
    public const int StringNotEmptyFieldNumber = 11;
    private bool stringNotEmpty_;
    /// <summary>
    /// Used for string fields, requires the string to be not empty (i.e different from "").
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StringNotEmpty {
      get { return stringNotEmpty_; }
      set {
        stringNotEmpty_ = value;
      }
    }

    /// <summary>Field number for the "repeated_count_min" field.</summary>
    public const int RepeatedCountMinFieldNumber = 12;
    private long repeatedCountMin_;
    /// <summary>
    /// Repeated field with at least this number of elements.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long RepeatedCountMin {
      get { return repeatedCountMin_; }
      set {
        repeatedCountMin_ = value;
      }
    }

    /// <summary>Field number for the "repeated_count_max" field.</summary>
    public const int RepeatedCountMaxFieldNumber = 13;
    private long repeatedCountMax_;
    /// <summary>
    /// Repeated field with at most this number of elements.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long RepeatedCountMax {
      get { return repeatedCountMax_; }
      set {
        repeatedCountMax_ = value;
      }
    }

    /// <summary>Field number for the "length_gt" field.</summary>
    public const int LengthGtFieldNumber = 14;
    private long lengthGt_;
    /// <summary>
    /// Field value of length greater than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LengthGt {
      get { return lengthGt_; }
      set {
        lengthGt_ = value;
      }
    }

    /// <summary>Field number for the "length_lt" field.</summary>
    public const int LengthLtFieldNumber = 15;
    private long lengthLt_;
    /// <summary>
    /// Field value of length smaller than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LengthLt {
      get { return lengthLt_; }
      set {
        lengthLt_ = value;
      }
    }

    /// <summary>Field number for the "length_eq" field.</summary>
    public const int LengthEqFieldNumber = 16;
    private long lengthEq_;
    /// <summary>
    /// Field value of integer strictly equal this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LengthEq {
      get { return lengthEq_; }
      set {
        lengthEq_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FieldValidator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FieldValidator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Regex != other.Regex) return false;
      if (IntGt != other.IntGt) return false;
      if (IntLt != other.IntLt) return false;
      if (MsgExists != other.MsgExists) return false;
      if (HumanError != other.HumanError) return false;
      if (FloatGt != other.FloatGt) return false;
      if (FloatLt != other.FloatLt) return false;
      if (FloatEpsilon != other.FloatEpsilon) return false;
      if (FloatGte != other.FloatGte) return false;
      if (FloatLte != other.FloatLte) return false;
      if (StringNotEmpty != other.StringNotEmpty) return false;
      if (RepeatedCountMin != other.RepeatedCountMin) return false;
      if (RepeatedCountMax != other.RepeatedCountMax) return false;
      if (LengthGt != other.LengthGt) return false;
      if (LengthLt != other.LengthLt) return false;
      if (LengthEq != other.LengthEq) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Regex.Length != 0) hash ^= Regex.GetHashCode();
      if (IntGt != 0L) hash ^= IntGt.GetHashCode();
      if (IntLt != 0L) hash ^= IntLt.GetHashCode();
      if (MsgExists != false) hash ^= MsgExists.GetHashCode();
      if (HumanError.Length != 0) hash ^= HumanError.GetHashCode();
      if (FloatGt != 0D) hash ^= FloatGt.GetHashCode();
      if (FloatLt != 0D) hash ^= FloatLt.GetHashCode();
      if (FloatEpsilon != 0D) hash ^= FloatEpsilon.GetHashCode();
      if (FloatGte != 0D) hash ^= FloatGte.GetHashCode();
      if (FloatLte != 0D) hash ^= FloatLte.GetHashCode();
      if (StringNotEmpty != false) hash ^= StringNotEmpty.GetHashCode();
      if (RepeatedCountMin != 0L) hash ^= RepeatedCountMin.GetHashCode();
      if (RepeatedCountMax != 0L) hash ^= RepeatedCountMax.GetHashCode();
      if (LengthGt != 0L) hash ^= LengthGt.GetHashCode();
      if (LengthLt != 0L) hash ^= LengthLt.GetHashCode();
      if (LengthEq != 0L) hash ^= LengthEq.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Regex.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Regex);
      }
      if (IntGt != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(IntGt);
      }
      if (IntLt != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(IntLt);
      }
      if (MsgExists != false) {
        output.WriteRawTag(32);
        output.WriteBool(MsgExists);
      }
      if (HumanError.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(HumanError);
      }
      if (FloatGt != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(FloatGt);
      }
      if (FloatLt != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(FloatLt);
      }
      if (FloatEpsilon != 0D) {
        output.WriteRawTag(65);
        output.WriteDouble(FloatEpsilon);
      }
      if (FloatGte != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(FloatGte);
      }
      if (FloatLte != 0D) {
        output.WriteRawTag(81);
        output.WriteDouble(FloatLte);
      }
      if (StringNotEmpty != false) {
        output.WriteRawTag(88);
        output.WriteBool(StringNotEmpty);
      }
      if (RepeatedCountMin != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(RepeatedCountMin);
      }
      if (RepeatedCountMax != 0L) {
        output.WriteRawTag(104);
        output.WriteInt64(RepeatedCountMax);
      }
      if (LengthGt != 0L) {
        output.WriteRawTag(112);
        output.WriteInt64(LengthGt);
      }
      if (LengthLt != 0L) {
        output.WriteRawTag(120);
        output.WriteInt64(LengthLt);
      }
      if (LengthEq != 0L) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(LengthEq);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Regex.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Regex);
      }
      if (IntGt != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IntGt);
      }
      if (IntLt != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IntLt);
      }
      if (MsgExists != false) {
        size += 1 + 1;
      }
      if (HumanError.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HumanError);
      }
      if (FloatGt != 0D) {
        size += 1 + 8;
      }
      if (FloatLt != 0D) {
        size += 1 + 8;
      }
      if (FloatEpsilon != 0D) {
        size += 1 + 8;
      }
      if (FloatGte != 0D) {
        size += 1 + 8;
      }
      if (FloatLte != 0D) {
        size += 1 + 8;
      }
      if (StringNotEmpty != false) {
        size += 1 + 1;
      }
      if (RepeatedCountMin != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RepeatedCountMin);
      }
      if (RepeatedCountMax != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RepeatedCountMax);
      }
      if (LengthGt != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LengthGt);
      }
      if (LengthLt != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LengthLt);
      }
      if (LengthEq != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(LengthEq);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FieldValidator other) {
      if (other == null) {
        return;
      }
      if (other.Regex.Length != 0) {
        Regex = other.Regex;
      }
      if (other.IntGt != 0L) {
        IntGt = other.IntGt;
      }
      if (other.IntLt != 0L) {
        IntLt = other.IntLt;
      }
      if (other.MsgExists != false) {
        MsgExists = other.MsgExists;
      }
      if (other.HumanError.Length != 0) {
        HumanError = other.HumanError;
      }
      if (other.FloatGt != 0D) {
        FloatGt = other.FloatGt;
      }
      if (other.FloatLt != 0D) {
        FloatLt = other.FloatLt;
      }
      if (other.FloatEpsilon != 0D) {
        FloatEpsilon = other.FloatEpsilon;
      }
      if (other.FloatGte != 0D) {
        FloatGte = other.FloatGte;
      }
      if (other.FloatLte != 0D) {
        FloatLte = other.FloatLte;
      }
      if (other.StringNotEmpty != false) {
        StringNotEmpty = other.StringNotEmpty;
      }
      if (other.RepeatedCountMin != 0L) {
        RepeatedCountMin = other.RepeatedCountMin;
      }
      if (other.RepeatedCountMax != 0L) {
        RepeatedCountMax = other.RepeatedCountMax;
      }
      if (other.LengthGt != 0L) {
        LengthGt = other.LengthGt;
      }
      if (other.LengthLt != 0L) {
        LengthLt = other.LengthLt;
      }
      if (other.LengthEq != 0L) {
        LengthEq = other.LengthEq;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Regex = input.ReadString();
            break;
          }
          case 16: {
            IntGt = input.ReadInt64();
            break;
          }
          case 24: {
            IntLt = input.ReadInt64();
            break;
          }
          case 32: {
            MsgExists = input.ReadBool();
            break;
          }
          case 42: {
            HumanError = input.ReadString();
            break;
          }
          case 49: {
            FloatGt = input.ReadDouble();
            break;
          }
          case 57: {
            FloatLt = input.ReadDouble();
            break;
          }
          case 65: {
            FloatEpsilon = input.ReadDouble();
            break;
          }
          case 73: {
            FloatGte = input.ReadDouble();
            break;
          }
          case 81: {
            FloatLte = input.ReadDouble();
            break;
          }
          case 88: {
            StringNotEmpty = input.ReadBool();
            break;
          }
          case 96: {
            RepeatedCountMin = input.ReadInt64();
            break;
          }
          case 104: {
            RepeatedCountMax = input.ReadInt64();
            break;
          }
          case 112: {
            LengthGt = input.ReadInt64();
            break;
          }
          case 120: {
            LengthLt = input.ReadInt64();
            break;
          }
          case 128: {
            LengthEq = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
